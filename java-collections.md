# Object и коллекции в Java
*Java Object Model & Java Collections Framework*

---

## 0. Обычный массив в Java — отправная точка (и почему не всегда подходит)

Массив — базовая структура данных: фиксированный размер + быстрый доступ по индексу.

```java
int[] a = new int[3];
a[0] = 10;
int x = a[0]; // O(1)
```

**Плюсы массивов**
- `O(1)` доступ по индексу, хорошая locality (быстро для CPU cache).
- минимум накладных расходов.
- поддержка примитивов (`int[]`, `double[]` и т.п.), без автобоксинга.

**Почему массив часто не подходит**
- **фиксированный размер**: чтобы “добавить” элемент — создаёшь новый массив и копируешь (`O(n)`).
- нет готовых операций уровня “контракта”: `add/remove/contains`, итерация через `Iterator`, диапазоны, сортированные представления.
- слабый полиморфизм в API: `int[]` и `String[]` — разные типы, а “общего контракта коллекции” у массива нет.
- если нужна **уникальность**, **сортировка**, **быстрый поиск**, **очередь/дек** — массив превращается в ручную реализацию структуры данных.

**Идея:** коллекции — это не “удобный массив”, а **контракты + готовые структуры данных** под разные сценарии.

---

## 1. `Object` как фундамент коллекций (equals/hashCode)

Коллекции в Java хранят объекты и для сравнения/поиска используют правила `Object`.

### Ключевые методы `Object` и где они всплывают в коллекциях
- `boolean equals(Object)` — логическое равенство (критично для `Set`, `Map`, `contains`, `remove`).
- `int hashCode()` — критично для hash-коллекций (`HashMap/HashSet/LinkedHashMap`).
- `String toString()` — удобно для логов/отладки содержимого коллекций.
- `Class<?> getClass()` — рефлексия/проверки типов (не коллекции-специфика, но часто рядом).
- `wait/notify/notifyAll` — синхронизация (важно помнить, но к JCF напрямую не привязано).

### Контракт `equals`
По умолчанию `equals` — сравнение ссылок (`==`). Когда мы переопределяем `equals`, обязаны соблюдать:
- reflexive: `x.equals(x)`
- symmetric: `x.equals(y) == y.equals(x)`
- transitive: если `x==y` и `y==z` (по equals), то `x==z`
- consistent: результат стабилен при неизменности объектов
- `x.equals(null) == false`

### Контракт `hashCode` и главное правило
Hash-коллекции сначала используют `hashCode`, а потом уточняют равенство через `equals`.

**Правило:**
- если `a.equals(b) == true`, то **`a.hashCode() == b.hashCode()` обязано быть true**
- но `a.hashCode() == b.hashCode()` **не обязано** означать `a.equals(b)`

```text
a.equals(b) == true  ⇒  a.hashCode() == b.hashCode()
a.hashCode() == b.hashCode()  ⇏  a.equals(b)
```

**Почему так:** hash — это `int`, коллизии неизбежны. Разные объекты могут попасть в один бакет. Но равные объекты обязаны попадать в один бакет, иначе поиск/удаление в `HashMap/HashSet` ломаются.

**Практическое правило:** переопределил `equals` → переопредели `hashCode` теми же значимыми полями.

---

## 2. Иерархия коллекций (две ветки в одном параграфе)

В Java есть **две связанные, но разные иерархии**: первая идёт от `Iterable → Collection` и включает `List/Set/Queue/Deque` с ключевыми реализациями (`ArrayList`, `LinkedList`, `HashSet`, `LinkedHashSet`, `TreeSet`, `ArrayDeque`), а вторая — это отдельная ветка `Map<K,V>` (не `Collection`), с ключевыми реализациями `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap` (а также legacy `Hashtable`). Первая ветка описывает контейнеры “элементов”, вторая — отображение “ключ → значение”.

### 2.1 Иерархия `Iterable` / `Collection`

```text
Iterable
 └─ Collection
    ├─ List
    │  ├─ ArrayList
    │  └─ LinkedList
    ├─ Set
    │  ├─ HashSet
    │  │  └─ LinkedHashSet
    │  └─ TreeSet
    └─ Queue
       └─ Deque
          ├─ ArrayDeque
          └─ LinkedList
```

### 2.2 Иерархия `Map`

```text
Map<K, V>
 ├─ HashMap
 │  └─ LinkedHashMap
 ├─ TreeMap
 ├─ ConcurrentHashMap
 └─ Hashtable
 ```

---

## 3. Контракты интерфейсов (без прыжка в реализации)

### `Iterable<T>`
Минимальный контракт “я перебираем”:
- гарантирует наличие `Iterator<T> iterator()`
- делает возможным `for-each`
- **не обещает** порядок/уникальность/стоимость операций

### `Iterator<E>`
Основные методы:
- `hasNext()` — есть ли следующий элемент
- `next()` — вернуть следующий элемент; если нет — `NoSuchElementException`
- `remove()` — **опционален**: может бросать `UnsupportedOperationException`

Семантика `remove()`:
- удаляет **последний элемент, который вернул `next()`**
- если вызвать `remove()` дважды подряд без `next()` между ними — `IllegalStateException`

Про fail-fast:
- итераторы большинства коллекций **fail-fast**: при структурной модификации коллекции “мимо итератора” часто получаем `ConcurrentModificationException`
- это **не** потокобезопасность, а защита от ошибок использования

### `Collection<E>`
Базовый контракт “группа элементов”:
- `add/remove/contains/size/clear/iterator`
- **не гарантирует** порядок и уникальность
- сложность операций зависит от реализации

### `List<E>`
Контракт упорядоченной последовательности:
- элементы имеют позицию/индекс
- порядок сохраняется
- дубликаты допустимы
- важные операции: `get(index)`, `add(index, e)`, `remove(index)`, `indexOf`

### `Set<E>`
Контракт уникальности:
- нельзя иметь два элемента `a` и `b` такие, что `a.equals(b) == true`
- в hash-реализациях критичны `equals/hashCode`

### `Queue<E>` и `Deque<E>`
`Queue` — договор про порядок извлечения. API даёт пары методов:
- `add` vs `offer`
- `remove` vs `poll`
- `element` vs `peek`

`Deque` расширяет `Queue`:
- операции с обоих концов (`addFirst/addLast`, `pollFirst/pollLast`)
- стек (`push/pop`)

### `Map<K,V>`
`Map` хранит **пары ключ–значение**:
- нельзя добавить “просто значение” — значение существует только как часть пары с ключом
- основные операции: `put/get/remove`, `containsKey`

Почему `Map` не `Iterable`:
- `Iterable` — “последовательность элементов”
- `Map` — “отображение”
- итерация делается через `keySet()`, `values()`, `entrySet()`

---

## 4. Абстрактные классы и мотивация

Абстрактные классы дают “скелет” реализации, чтобы:
- не дублировать код в реализациях
- обеспечить единые `equals/hashCode/toString` для коллекций
- дать дефолтные реализации части методов

Ключевые:
- `AbstractCollection`, `AbstractList`, `AbstractSet`, `AbstractQueue`, `AbstractMap`

---

## 5. Comparable/Comparator

### `Comparable<T>`
- “естественный порядок” внутри класса
- `int compareTo(T other)`
- один порядок на тип

### `Comparator<T>`
- внешняя стратегия сравнения
- `int compare(T a, T b)`
- несколько компараторов под разные сценарии

Важно для `TreeSet/TreeMap`:
- `compare(a, b) == 0` ⇒ элементы считаются одинаковыми (влияет на уникальность)

---

## 6. Конкретные реализации (подробно: интерфейсы, внутренности, сложность, примеры)

### 6.1 `ArrayList`
**Интерфейсы:** `List`, `RandomAccess`  
**Внутри:** динамический массив `Object[] elementData`, расширение с копированием.

**Сложности:**
- `get(i)` → `O(1)`
- `add(e)` → `O(1)` амортизированно
- `add/remove(i)` → `O(n)` из-за сдвига
- `contains` → `O(n)`

**Пример**
```java
List<String> l = new ArrayList<>();
l.add("A"); l.add("B"); l.add("C");
l.remove(0); // O(n)
```

### 6.2 `LinkedList`
**Интерфейсы:** `List`, `Deque`, `Queue`  
**Внутри:** двусвязные узлы `Node(prev, item, next)`.

**Сложности:**
- операции на концах → `O(1)`
- `get(i)` → `O(n)`
- `contains` → `O(n)`

**Пример**
```java
Deque<Integer> d = new LinkedList<>();
d.addFirst(1); d.addLast(2);
d.pollFirst(); // O(1)
```

### 6.3 Hash-коллекции: `HashSet`, `HashMap`, `LinkedHashMap`
#### `HashMap<K,V>`
**Внутри:** массив бакетов; индекс из `hashCode`; в бакете список, при коллизиях (Java 8+) возможна древовидная структура.  
**Параметры:** `loadFactor` и resize (перехеширование).

**Сложности (в среднем):**
- `put/get/remove/containsKey` → `O(1)`

**Пример**
```java
Map<String, Integer> m = new HashMap<>();
m.put("a", 1);
int v = m.get("a"); // O(1) average
```

#### `HashSet<E>`
**Внутри:** `HashMap<E, Object>` (элемент хранится как ключ).  
**Сложности:** membership-операции в среднем `O(1)`.

#### `LinkedHashMap/LinkedHashSet`
Hash-структуры + стабильный порядок обхода (обычно порядок вставки). Цена — память/накладные расходы.

### 6.4 Tree-коллекции: `TreeSet`, `TreeMap`
#### `TreeMap<K,V>`
**Интерфейсы:** `SortedMap`, `NavigableMap`  
**Внутри:** красно-чёрное дерево; сравнение ключей через `Comparator/Comparable`.

**Сложности:**
- `put/get/remove` → `O(log n)`

**Пример**
```java
NavigableMap<String,Integer> tm = new TreeMap<>();
tm.put("b", 2); tm.put("a", 1);
tm.firstKey(); // "a"
```

#### `TreeSet<E>`
Построен поверх `TreeMap<E, Object>`. Уникальность определяется сравнением (`compare==0`).

---

## 7. Сводная таблица сложности (в среднем)

| Структура | Доступ/Получение | Вставка | Удаление | Поиск/contains |
|---|---:|---:|---:|---:|
| ArrayList | `get` O(1) | `add` O(1)* | `remove(i)` O(n) | O(n) |
| LinkedList | `get` O(n) | на концах O(1) | на концах O(1) | O(n) |
| HashSet | — | O(1) | O(1) | O(1) |
| TreeSet | — | O(log n) | O(log n) | O(log n) |
| HashMap | `get` O(1) | O(1) | O(1) | `containsKey` O(1) |
| LinkedHashMap | `get` O(1) | O(1) | O(1) | O(1) |
| TreeMap | `get` O(log n) | O(log n) | O(log n) | O(log n) |

\* амортизированно

---

## Итоговая модель
- массив — низкоуровневый инструмент (быстро, но ограниченно)
- `Object` задаёт правила равенства, без которых ломаются hash-структуры
- интерфейсы задают контракты (что гарантируется)
- абстрактные классы дают общий скелет поведения
- `Comparable/Comparator` определяют сортированный мир (`Tree*`) и влияют на уникальность
- реализации — это структуры данных, которые и определяют стоимость операций
