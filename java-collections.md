# Object и коллекции в Java
*Java Object Model & Java Collections Framework*

---

## 0. Обычный массив в Java — отправная точка (и почему не всегда подходит)

Массив — базовая структура данных: фиксированный размер + быстрый доступ по индексу.

```java
int[] a = new int[3];
a[0] = 10;
int x = a[0]; // O(1)
```

**Плюсы массивов**
- `O(1)` доступ по индексу, хорошая locality (быстро для CPU cache).
- минимум накладных расходов.
- поддержка примитивов (`int[]`, `double[]` и т.п.), без автобоксинга.

**Почему массив часто не подходит**
- **фиксированный размер**: чтобы “добавить” элемент — создаёшь новый массив и копируешь (`O(n)`).
- нет готовых операций уровня “контракта”: `add/remove/contains`, итерация через `Iterator`, диапазоны, сортированные представления.
- слабый полиморфизм в API: `int[]` и `String[]` — разные типы, а “общего контракта коллекции” у массива нет.
- если нужна **уникальность**, **сортировка**, **быстрый поиск**, **очередь/дек** — массив превращается в ручную реализацию структуры данных.

**Идея:** коллекции — это не “удобный массив”, а **контракты + готовые структуры данных** под разные сценарии.

---

## 1. `Object` как фундамент коллекций (equals/hashCode)

Коллекции в Java хранят объекты и для сравнения/поиска используют правила `Object`.

### Ключевые методы `Object` и где они всплывают в коллекциях
- `boolean equals(Object)` — логическое равенство (критично для `Set`, `Map`, `contains`, `remove`).
- `int hashCode()` — критично для hash-коллекций (`HashMap/HashSet/LinkedHashMap`).
- `String toString()` — удобно для логов/отладки содержимого коллекций.
- `Class<?> getClass()` — рефлексия/проверки типов (не коллекции-специфика, но часто рядом).
- `wait/notify/notifyAll` — синхронизация (важно помнить, но к JCF напрямую не привязано).

### Контракт `equals`
По умолчанию `equals` — сравнение ссылок (`==`). Когда мы переопределяем `equals`, обязаны соблюдать:
- reflexive: `x.equals(x)`
- symmetric: `x.equals(y) == y.equals(x)`
- transitive: если `x==y` и `y==z` (по equals), то `x==z`
- consistent: результат стабилен при неизменности объектов
- `x.equals(null) == false`

### Контракт `hashCode` и главное правило
Hash-коллекции сначала используют `hashCode`, а потом уточняют равенство через `equals`.

**Правило:**
- если `a.equals(b) == true`, то **`a.hashCode() == b.hashCode()` обязано быть true**
- но `a.hashCode() == b.hashCode()` **не обязано** означать `a.equals(b)`

```text
a.equals(b) == true  ⇒  a.hashCode() == b.hashCode()
a.hashCode() == b.hashCode()  ⇏  a.equals(b)
```

**Почему так:** hash — это `int`, коллизии неизбежны. Разные объекты могут попасть в один бакет. Но равные объекты обязаны попадать в один бакет, иначе поиск/удаление в `HashMap/HashSet` ломаются.

**Практическое правило:** переопределил `equals` → переопредели `hashCode` теми же значимыми полями.

---

## 2. Иерархия коллекций (две ветки в одном параграфе)

В Java есть **две связанные, но разные иерархии**: первая идёт от `Iterable → Collection` и включает `List/Set/Queue/Deque` с ключевыми реализациями (`ArrayList`, `LinkedList`, `HashSet`, `LinkedHashSet`, `TreeSet`, `ArrayDeque`), а вторая — это отдельная ветка `Map<K,V>` (не `Collection`), с ключевыми реализациями `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap` (а также legacy `Hashtable`). Первая ветка описывает контейнеры “элементов”, вторая — отображение “ключ → значение”.

### 2.1 Иерархия `Iterable` / `Collection`

```text
Iterable
 └─ Collection
    ├─ List
    │  ├─ ArrayList
    │  └─ LinkedList
    ├─ Set
    │  ├─ HashSet
    │  │  └─ LinkedHashSet
    │  └─ TreeSet
    └─ Queue
       └─ Deque
          ├─ ArrayDeque
          └─ LinkedList
```

### 2.2 Иерархия `Map`

```text
Map<K, V>
 ├─ HashMap
 │  └─ LinkedHashMap
 ├─ TreeMap
 ├─ ConcurrentHashMap
 └─ Hashtable
 ```

---

## 3. Контракты интерфейсов (без прыжка в реализации)

### `Iterable<T>`
Минимальный контракт “я перебираем”:
- гарантирует наличие `Iterator<T> iterator()`
- делает возможным `for-each`
- **не обещает** порядок/уникальность/стоимость операций

### `Iterator<E>`
Основные методы:
- `hasNext()` — есть ли следующий элемент
- `next()` — вернуть следующий элемент; если нет — `NoSuchElementException`
- `remove()` — **опционален**: может бросать `UnsupportedOperationException`

Семантика `remove()`:
- удаляет **последний элемент, который вернул `next()`**
- если вызвать `remove()` дважды подряд без `next()` между ними — `IllegalStateException`

Про fail-fast:
- итераторы большинства коллекций **fail-fast**: при структурной модификации коллекции “мимо итератора” часто получаем `ConcurrentModificationException`
- это **не** потокобезопасность, а защита от ошибок использования

### `Collection<E>`
Базовый контракт “группа элементов”:
- `add/remove/contains/size/clear/iterator`
- **не гарантирует** порядок и уникальность
- сложность операций зависит от реализации

### `List<E>`
Контракт упорядоченной последовательности:
- элементы имеют позицию/индекс
- порядок сохраняется
- дубликаты допустимы
- важные операции: `get(index)`, `add(index, e)`, `remove(index)`, `indexOf`

### `Set<E>`
Контракт уникальности:
- нельзя иметь два элемента `a` и `b` такие, что `a.equals(b) == true`
- в hash-реализациях критичны `equals/hashCode`

### `Queue<E>` и `Deque<E>`
`Queue` — договор про порядок извлечения. API даёт пары методов:
- `add` vs `offer`
- `remove` vs `poll`
- `element` vs `peek`

`Deque` расширяет `Queue`:
- операции с обоих концов (`addFirst/addLast`, `pollFirst/pollLast`)
- стек (`push/pop`)

### `Map<K,V>`
`Map` хранит **пары ключ–значение**:
- нельзя добавить “просто значение” — значение существует только как часть пары с ключом
- основные операции: `put/get/remove`, `containsKey`

Почему `Map` не `Iterable`:
- `Iterable` — “последовательность элементов”
- `Map` — “отображение”
- итерация делается через `keySet()`, `values()`, `entrySet()`

---

## 4. Абстрактные классы и мотивация

Абстрактные классы дают “скелет” реализации, чтобы:
- не дублировать код в реализациях
- обеспечить единые `equals/hashCode/toString` для коллекций
- дать дефолтные реализации части методов

Ключевые:
- `AbstractCollection`, `AbstractList`, `AbstractSet`, `AbstractQueue`, `AbstractMap`

---

## 5. Comparable/Comparator

### `Comparable<T>`
- “естественный порядок” внутри класса
- `int compareTo(T other)`
- один порядок на тип

### `Comparator<T>`
- внешняя стратегия сравнения
- `int compare(T a, T b)`
- несколько компараторов под разные сценарии

Важно для `TreeSet/TreeMap`:
- `compare(a, b) == 0` ⇒ элементы считаются одинаковыми (влияет на уникальность)

---

## 6. Конкретные реализации коллекций (устройство, контракты, equals/hashCode, сложность)

В этом разделе рассматриваются конкретные реализации Java Collections Framework:
- какие интерфейсы они реализуют
- какая структура данных используется внутри
- как и где применяются `equals`, `hashCode`, `Comparator`
- какова асимптотическая сложность операций

---

### 6.1 `ArrayList`

**Реализуемые интерфейсы**
- `List`
- `RandomAccess`

**Внутреннее устройство**
- динамический массив `Object[]`
- при переполнении создаётся новый массив большего размера и копируются элементы

**Использование `equals` / `hashCode`**
- `equals` используется в методах:
  - `contains`
  - `remove(Object)`
  - `indexOf`
- `hashCode` не используется
- порядок элементов важен, уникальность не контролируется

**Следствия**
- можно хранить дубликаты
- ошибки в `hashCode` не влияют на корректность `ArrayList`
- поиск элемента всегда линейный

**Сложность**
- `get(i)` — `O(1)`
- `add(e)` — `O(1)` амортизированно
- `add(i, e)` / `remove(i)` — `O(n)`
- `contains` — `O(n)`

---

### 6.2 `LinkedList`

**Реализуемые интерфейсы**
- `List`
- `Queue`
- `Deque`

**Внутреннее устройство**
- двусвязный список узлов (`prev`, `item`, `next`)

**Использование `equals` / `hashCode`**
- `equals` используется в:
  - `contains`
  - `remove(Object)`
- `hashCode` не используется
- порядок элементов важен

**Следствия**
- быстрые операции на концах списка
- линейный поиск элемента
- дубликаты допустимы

**Сложность**
- `addFirst` / `addLast` — `O(1)`
- `pollFirst` / `pollLast` — `O(1)`
- `get(i)` — `O(n)`
- `contains` — `O(n)`

---

### 6.3 Hash-коллекции: `HashSet`, `HashMap`, `LinkedHashMap`

#### 6.3.1 `HashMap<K, V>`

**Реализуемые интерфейсы**
- `Map`

**Внутреннее устройство**
- массив бакетов
- индекс бакета вычисляется из `hashCode` ключа
- внутри бакета:
  - список элементов
  - при большом числе коллизий (Java 8+) — дерево

**Использование `equals` / `hashCode`**
- используются только для ключей
- алгоритм поиска:
  1. вычисляется `hashCode` ключа
  2. выбирается бакет
  3. внутри бакета применяется `equals`

**Критические требования**
- если `equals` переопределён, `hashCode` обязан быть согласован
- изменение ключа после `put` делает элемент недоступным через `get`

**Следствия**
- некорректный `hashCode`:
  - ломает уникальность ключей
  - ухудшает производительность
- значения (`V`) не участвуют в сравнении ключей

**Сложность (в среднем)**
- `put` / `get` / `remove` / `containsKey` — `O(1)`

---

#### 6.3.2 `HashSet<E>`

**Реализуемые интерфейсы**
- `Set`

**Внутреннее устройство**
- реализован поверх `HashMap<E, Object>`
- элемент `E` хранится как ключ `Map`

**Использование `equals` / `hashCode`**
- уникальность определяется `equals`
- распределение по бакетам — через `hashCode`

**Следствия**
- одинаковые `equals`, но разные `hashCode` → дубликаты
- плохой `hashCode` → деградация до линейного поиска

**Сложность**
- `add` / `remove` / `contains` — `O(1)` в среднем

---

#### 6.3.3 `LinkedHashMap` / `LinkedHashSet`

**Особенности**
- hash-коллекции с сохранением порядка
- порядок обычно соответствует порядку вставки
- у `LinkedHashMap` возможен порядок доступа

**Использование `equals` / `hashCode`**
- идентично `HashMap` / `HashSet`
- дополнительно поддерживается связный список элементов

**Цена**
- большее потребление памяти
- дополнительный overhead операций

---

### 6.4 Tree-коллекции: `TreeSet`, `TreeMap`

#### 6.4.1 `TreeMap<K, V>`

**Реализуемые интерфейсы**
- `Map`
- `SortedMap`
- `NavigableMap`

**Внутреннее устройство**
- красно-чёрное дерево
- элементы упорядочены по `Comparator` или `Comparable`

**Использование `equals` / `hashCode`**
- не используются для определения уникальности
- уникальность определяется сравнением:
  compare(k1, k2) == 0

**Следствия**
- `equals` может возвращать false, но ключ не будет добавлен
- `Comparator` должен быть логически согласован с `equals`

**Сложность**
- `put` / `get` / `remove` — `O(log n)`

---

#### 6.4.2 `TreeSet<E>`

**Реализуемые интерфейсы**
- `Set`
- `SortedSet`
- `NavigableSet`

**Внутреннее устройство**
- реализован поверх `TreeMap<E, Object>`

**Использование `Comparator`**
- compare(e1, e2) == 0 ⇒ элементы считаются одинаковыми
- `equals` не участвует в проверке уникальности

**Сложность**
- `add` / `remove` / `contains` — `O(log n)`

---

### 6.5 Ключевые выводы по реализациям

- `List`-реализации используют только `equals`
- hash-коллекции используют `hashCode` + `equals`
- tree-коллекции используют `Comparator` / `Comparable`
- ошибки в `equals` / `hashCode` ломают `HashSet` и `HashMap`
- ошибки в `Comparator` ломают `TreeSet` и `TreeMap`

---

## 7. Сводная таблица сложности (в среднем)

| Структура | Доступ/Получение | Вставка | Удаление | Поиск/contains |
|---|---:|---:|---:|---:|
| ArrayList | `get` O(1) | `add` O(1)* | `remove(i)` O(n) | O(n) |
| LinkedList | `get` O(n) | на концах O(1) | на концах O(1) | O(n) |
| HashSet | — | O(1) | O(1) | O(1) |
| TreeSet | — | O(log n) | O(log n) | O(log n) |
| HashMap | `get` O(1) | O(1) | O(1) | `containsKey` O(1) |
| LinkedHashMap | `get` O(1) | O(1) | O(1) | O(1) |
| TreeMap | `get` O(log n) | O(log n) | O(log n) | O(log n) |

\* амортизированно

---

## Итоговая модель
- массив — низкоуровневый инструмент (быстро, но ограниченно)
- `Object` задаёт правила равенства, без которых ломаются hash-структуры
- интерфейсы задают контракты (что гарантируется)
- абстрактные классы дают общий скелет поведения
- `Comparable/Comparator` определяют сортированный мир (`Tree*`) и влияют на уникальность
- реализации — это структуры данных, которые и определяют стоимость операций
