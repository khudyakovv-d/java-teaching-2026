# Object и коллекции в Java
*Java Object Model & Java Collections Framework*

---

## 0. Обычный массив в Java — отправная точка

Прежде чем говорить о коллекциях, важно понять, **от чего они нас спасают**.
Коллекции в Java появились как ответ на ограничения массивов.

### Что такое массив в Java

Массив — это:
- непрерывный участок памяти
- фиксированного размера
- с доступом по индексу

```java
int[] numbers = new int[3];
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;

int x = numbers[1]; // O(1)
```

### Плюсы массивов

- Быстрый доступ по индексу — `O(1)`
- Минимальные накладные расходы
- Поддержка примитивов (`int[]`, `double[]`)

### Ограничения массивов

- Фиксированный размер
- Нет операций высокого уровня (`add`, `remove`, `contains`)
- Нет контрактов поведения
- Ограниченная работа с Generics

**Вывод:** массив хорош для простых и заранее известных сценариев,
но плохо масштабируется по требованиям.

---

## 1. `Object` как основа коллекций

Java Collections Framework целиком опирается на `Object`.

Коллекции:
- хранят объекты
- используют `equals()` и `hashCode()`
- чувствительны к корректности этих методов

### Контракт `equals` и `hashCode`

Если два объекта равны по `equals()`, они **обязаны** иметь одинаковый `hashCode()`.
Обратное неверно.

---

## 2. Общая идея коллекций и иерархия

Collections Framework строится от контрактов поведения.

```text
Iterable
  |
Collection
  |
  +-- List
  +-- Set
  +-- Queue
        |
        +-- Deque

Map<K, V> — отдельная иерархия
```

---

## 3. Контракты интерфейсов

- `Iterable` — перебор
- `Iterator` — пошаговый обход
- `Collection` — базовый контракт
- `List` — порядок и индексы
- `Set` — уникальность
- `Queue / Deque` — управление порядком
- `Map` — отображение ключ → значение

---

## 4. Абстрактные классы

Абстрактные классы (`AbstractList`, `AbstractSet`, `AbstractMap` и др.):
- реализуют общую логику
- уменьшают дублирование
- не определяют структуру хранения

---

## 5. Сравнение элементов

- `Comparable` — естественный порядок
- `Comparator` — внешний порядок

В `TreeSet` / `TreeMap` сравнение определяет уникальность элементов.

---

## 6. Конкретные реализации

### ArrayList
- динамический массив
- реализует `RandomAccess`
- быстрый `get`, дорогие вставки в середине

### LinkedList
- двусвязный список
- реализует `List` и `Deque`
- быстрые вставки, медленный доступ по индексу

### HashSet / HashMap
- основаны на хеш-таблицах
- используют `hashCode` + `equals`
- операции в среднем `O(1)`

### TreeSet / TreeMap
- красно-чёрные деревья
- используют `Comparator` / `Comparable`
- все операции `O(log n)`

---

## 7. Сводная таблица сложности

| Структура | Доступ | Вставка | Удаление |
|----------|--------|----------|----------|
| ArrayList | O(1) | O(1)* | O(n) |
| LinkedList | O(n) | O(1) | O(1)** |
| HashSet / HashMap | O(1) | O(1) | O(1) |
| TreeSet / TreeMap | O(log n) | O(log n) | O(log n) |

---

## Итог

Коллекции — это:
- контракты поведения
- структуры данных
- алгоритмы

Важно понимать не только API, но и то,
**какая структура данных работает под капотом**.
