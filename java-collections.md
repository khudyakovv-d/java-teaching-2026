# Object и коллекции в Java
*Java Object Model & Java Collections Framework*

---

## 0. Обычный массив в Java — отправная точка

Массив — базовая структура данных в Java:
- непрерывный участок памяти
- фиксированный размер
- доступ по индексу за `O(1)`

```java
int[] a = new int[3];
a[0] = 10;
int x = a[0]; // O(1)
```

**Плюсы массивов**
- быстрый доступ по индексу
- минимальные накладные расходы
- поддержка примитивов

**Ограничения массивов**
- фиксированный размер
- отсутствие операций `add/remove/contains`
- отсутствие контрактов поведения
- ограниченный полиморфизм

Коллекции решают эти ограничения, предоставляя контракты и готовые структуры данных.

---

## 1. `Object` как фундамент коллекций

Коллекции работают с объектами и используют правила `equals()` и `hashCode()`.

Ключевое правило:

```text
a.equals(b) == true  ⇒  a.hashCode() == b.hashCode()
a.hashCode() == b.hashCode()  ⇏  a.equals(b)
```

Нарушение этого правила приводит к некорректной работе `Set` и `Map`.

---

## 2. Иерархия коллекций

### 2.1 Иерархия `Iterable` / `Collection`

```text
Iterable
 └─ Collection
    ├─ List
    │  ├─ ArrayList
    │  └─ LinkedList
    ├─ Set
    │  ├─ HashSet
    │  │  └─ LinkedHashSet
    │  └─ TreeSet
    └─ Queue
       └─ Deque
          ├─ ArrayDeque
          └─ LinkedList
```

### 2.2 Иерархия `Map`

```text
Map<K, V>
 ├─ HashMap
 │  └─ LinkedHashMap
 ├─ TreeMap
 ├─ ConcurrentHashMap
 └─ Hashtable
```

`Collection` описывает контейнеры элементов.  
`Map` описывает отображение ключ → значение и не является `Collection`.

---

## 3. Контракты интерфейсов

### Iterable
- объект можно перебирать (`for-each`)
- гарантирует наличие `Iterator`

### Iterator
- пошаговый обход (`hasNext / next`)
- опциональный `remove`
- большинство итераторов — fail-fast

### Collection
- базовый контракт группы элементов
- не гарантирует порядок и уникальность

### List
- упорядоченная последовательность
- доступ по индексу
- дубликаты допустимы

### Set
- уникальность элементов
- зависит от `equals/hashCode`

### Queue / Deque
- управление порядком извлечения
- `Deque` поддерживает операции с обоих концов

### Map
- хранит пары `key → value`
- не является `Iterable`
- итерирование через `keySet`, `values`, `entrySet`

---

## 4. Абстрактные классы

Абстрактные классы предоставляют общую реализацию контрактов.

```text
AbstractCollection
AbstractList
AbstractSet
AbstractQueue
AbstractMap
```

Они уменьшают дублирование и не задают конкретную структуру хранения.

---

## 5. Comparable и Comparator

### Comparable
- естественный порядок
- один порядок на класс

### Comparator
- внешний порядок
- несколько стратегий сортировки

В `TreeSet` и `TreeMap` сравнение определяет уникальность:
`compare(a, b) == 0` ⇒ элементы считаются одинаковыми.

---

## 6. Конкретные реализации

### ArrayList
- интерфейсы: `List`, `RandomAccess`
- внутренняя структура: динамический массив

Сложность:
- `get` — `O(1)`
- `add` — `O(1)` амортизированно
- `remove(i)` — `O(n)`

---

### LinkedList
- интерфейсы: `List`, `Deque`, `Queue`
- внутренняя структура: двусвязный список

Сложность:
- операции на концах — `O(1)`
- `get(i)` — `O(n)`

---

### HashSet
- интерфейс: `Set`
- реализация поверх `HashMap`

Сложность:
- `add/contains/remove` — `O(1)` в среднем

---

### TreeSet
- интерфейсы: `Set`, `SortedSet`, `NavigableSet`
- реализация поверх красно-чёрного дерева

Сложность:
- основные операции — `O(log n)`

---

### HashMap
- интерфейс: `Map`
- массив бакетов + цепочки / деревья

Сложность:
- `get/put/remove` — `O(1)` в среднем

---

### TreeMap
- интерфейсы: `Map`, `SortedMap`, `NavigableMap`
- красно-чёрное дерево

Сложность:
- основные операции — `O(log n)`

---

## 7. Сводная таблица сложности

| Структура | Доступ | Вставка | Удаление | Поиск |
|---------|--------|----------|----------|-------|
| ArrayList | O(1) | O(1)* | O(n) | O(n) |
| LinkedList | O(n) | O(1) | O(1)** | O(n) |
| HashSet | — | O(1) | O(1) | O(1) |
| TreeSet | — | O(log n) | O(log n) | O(log n) |
| HashMap | O(1) | O(1) | O(1) | O(1) |
| TreeMap | O(log n) | O(log n) | O(log n) | O(log n) |

---

## Итог

Коллекции в Java — это:
- контракты поведения
- абстрактные базовые реализации
- конкретные структуры данных

Выбор коллекции определяется требуемыми операциями и их сложностью.
